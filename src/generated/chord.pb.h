// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chord.proto

#ifndef PROTOBUF_INCLUDED_chord_2eproto
#define PROTOBUF_INCLUDED_chord_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chord_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_chord_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[5]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_chord_2eproto();
namespace chord {
class DumpRequest;
class DumpRequestDefaultTypeInternal;
extern DumpRequestDefaultTypeInternal _DumpRequest_default_instance_;
class DumpResponse;
class DumpResponseDefaultTypeInternal;
extern DumpResponseDefaultTypeInternal _DumpResponse_default_instance_;
class Finger;
class FingerDefaultTypeInternal;
extern FingerDefaultTypeInternal _Finger_default_instance_;
class FingerTable;
class FingerTableDefaultTypeInternal;
extern FingerTableDefaultTypeInternal _FingerTable_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
}  // namespace chord
namespace google {
namespace protobuf {
template<> ::chord::DumpRequest* Arena::CreateMaybeMessage<::chord::DumpRequest>(Arena*);
template<> ::chord::DumpResponse* Arena::CreateMaybeMessage<::chord::DumpResponse>(Arena*);
template<> ::chord::Finger* Arena::CreateMaybeMessage<::chord::Finger>(Arena*);
template<> ::chord::FingerTable* Arena::CreateMaybeMessage<::chord::FingerTable>(Arena*);
template<> ::chord::Node* Arena::CreateMaybeMessage<::chord::Node>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chord {

// ===================================================================

class DumpRequest final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.DumpRequest) */ {
 public:
  DumpRequest();
  virtual ~DumpRequest();

  DumpRequest(const DumpRequest& from);

  inline DumpRequest& operator=(const DumpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpRequest(DumpRequest&& from) noexcept
    : DumpRequest() {
    *this = ::std::move(from);
  }

  inline DumpRequest& operator=(DumpRequest&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DumpRequest& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpRequest* internal_default_instance() {
    return reinterpret_cast<const DumpRequest*>(
               &_DumpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(DumpRequest* other);
  friend void swap(DumpRequest& a, DumpRequest& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpRequest* New() const final {
    return CreateMaybeMessage<DumpRequest>(nullptr);
  }

  DumpRequest* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpRequest>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DumpRequest& from);
  void MergeFrom(const DumpRequest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DumpRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.DumpRequest)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class DumpResponse final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.DumpResponse) */ {
 public:
  DumpResponse();
  virtual ~DumpResponse();

  DumpResponse(const DumpResponse& from);

  inline DumpResponse& operator=(const DumpResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DumpResponse(DumpResponse&& from) noexcept
    : DumpResponse() {
    *this = ::std::move(from);
  }

  inline DumpResponse& operator=(DumpResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DumpResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DumpResponse* internal_default_instance() {
    return reinterpret_cast<const DumpResponse*>(
               &_DumpResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(DumpResponse* other);
  friend void swap(DumpResponse& a, DumpResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DumpResponse* New() const final {
    return CreateMaybeMessage<DumpResponse>(nullptr);
  }

  DumpResponse* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DumpResponse>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DumpResponse& from);
  void MergeFrom(const DumpResponse& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DumpResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node node = 1;
  bool has_node() const;
  void clear_node();
  static const int kNodeFieldNumber = 1;
  const ::chord::Node& node() const;
  ::chord::Node* release_node();
  ::chord::Node* mutable_node();
  void set_allocated_node(::chord::Node* node);

  // @@protoc_insertion_point(class_scope:chord.DumpResponse)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* node_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(nullptr);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // string succ = 3;
  void clear_succ();
  static const int kSuccFieldNumber = 3;
  const ::std::string& succ() const;
  void set_succ(const ::std::string& value);
  #if LANG_CXX11
  void set_succ(::std::string&& value);
  #endif
  void set_succ(const char* value);
  void set_succ(const char* value, size_t size);
  ::std::string* mutable_succ();
  ::std::string* release_succ();
  void set_allocated_succ(::std::string* succ);

  // string pred = 4;
  void clear_pred();
  static const int kPredFieldNumber = 4;
  const ::std::string& pred() const;
  void set_pred(const ::std::string& value);
  #if LANG_CXX11
  void set_pred(::std::string&& value);
  #endif
  void set_pred(const char* value);
  void set_pred(const char* value, size_t size);
  ::std::string* mutable_pred();
  ::std::string* release_pred();
  void set_allocated_pred(::std::string* pred);

  // .chord.FingerTable tbl = 5;
  bool has_tbl() const;
  void clear_tbl();
  static const int kTblFieldNumber = 5;
  const ::chord::FingerTable& tbl() const;
  ::chord::FingerTable* release_tbl();
  ::chord::FingerTable* mutable_tbl();
  void set_allocated_tbl(::chord::FingerTable* tbl);

  // uint32 m = 2;
  void clear_m();
  static const int kMFieldNumber = 2;
  ::google::protobuf::uint32 m() const;
  void set_m(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chord.Node)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::internal::ArenaStringPtr succ_;
  ::google::protobuf::internal::ArenaStringPtr pred_;
  ::chord::FingerTable* tbl_;
  ::google::protobuf::uint32 m_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FingerTable final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FingerTable) */ {
 public:
  FingerTable();
  virtual ~FingerTable();

  FingerTable(const FingerTable& from);

  inline FingerTable& operator=(const FingerTable& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FingerTable(FingerTable&& from) noexcept
    : FingerTable() {
    *this = ::std::move(from);
  }

  inline FingerTable& operator=(FingerTable&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FingerTable& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FingerTable* internal_default_instance() {
    return reinterpret_cast<const FingerTable*>(
               &_FingerTable_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FingerTable* other);
  friend void swap(FingerTable& a, FingerTable& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FingerTable* New() const final {
    return CreateMaybeMessage<FingerTable>(nullptr);
  }

  FingerTable* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FingerTable>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FingerTable& from);
  void MergeFrom(const FingerTable& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FingerTable* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .chord.Finger fingers = 1;
  int fingers_size() const;
  void clear_fingers();
  static const int kFingersFieldNumber = 1;
  ::chord::Finger* mutable_fingers(int index);
  ::google::protobuf::RepeatedPtrField< ::chord::Finger >*
      mutable_fingers();
  const ::chord::Finger& fingers(int index) const;
  ::chord::Finger* add_fingers();
  const ::google::protobuf::RepeatedPtrField< ::chord::Finger >&
      fingers() const;

  // @@protoc_insertion_point(class_scope:chord.FingerTable)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::chord::Finger > fingers_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class Finger final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.Finger) */ {
 public:
  Finger();
  virtual ~Finger();

  Finger(const Finger& from);

  inline Finger& operator=(const Finger& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Finger(Finger&& from) noexcept
    : Finger() {
    *this = ::std::move(from);
  }

  inline Finger& operator=(Finger&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Finger& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Finger* internal_default_instance() {
    return reinterpret_cast<const Finger*>(
               &_Finger_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Finger* other);
  friend void swap(Finger& a, Finger& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Finger* New() const final {
    return CreateMaybeMessage<Finger>(nullptr);
  }

  Finger* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Finger>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Finger& from);
  void MergeFrom(const Finger& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Finger* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // uint32 idx = 2;
  void clear_idx();
  static const int kIdxFieldNumber = 2;
  ::google::protobuf::uint32 idx() const;
  void set_idx(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chord.Finger)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::uint32 idx_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// DumpRequest

// -------------------------------------------------------------------

// DumpResponse

// .chord.Node node = 1;
inline bool DumpResponse::has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline void DumpResponse::clear_node() {
  if (GetArenaNoVirtual() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::chord::Node& DumpResponse::node() const {
  const ::chord::Node* p = node_;
  // @@protoc_insertion_point(field_get:chord.DumpResponse.node)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* DumpResponse::release_node() {
  // @@protoc_insertion_point(field_release:chord.DumpResponse.node)
  
  ::chord::Node* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::chord::Node* DumpResponse::mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    node_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.DumpResponse.node)
  return node_;
}
inline void DumpResponse::set_allocated_node(::chord::Node* node) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      node = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:chord.DumpResponse.node)
}

// -------------------------------------------------------------------

// Node

// string addr = 1;
inline void Node::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::addr() const {
  // @@protoc_insertion_point(field_get:chord.Node.addr)
  return addr_.GetNoArena();
}
inline void Node::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chord.Node.addr)
}
#if LANG_CXX11
inline void Node::set_addr(::std::string&& value) {
  
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chord.Node.addr)
}
#endif
inline void Node::set_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chord.Node.addr)
}
inline void Node::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chord.Node.addr)
}
inline ::std::string* Node::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:chord.Node.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_addr() {
  // @@protoc_insertion_point(field_release:chord.Node.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_addr(::std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:chord.Node.addr)
}

// uint32 m = 2;
inline void Node::clear_m() {
  m_ = 0u;
}
inline ::google::protobuf::uint32 Node::m() const {
  // @@protoc_insertion_point(field_get:chord.Node.m)
  return m_;
}
inline void Node::set_m(::google::protobuf::uint32 value) {
  
  m_ = value;
  // @@protoc_insertion_point(field_set:chord.Node.m)
}

// string succ = 3;
inline void Node::clear_succ() {
  succ_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::succ() const {
  // @@protoc_insertion_point(field_get:chord.Node.succ)
  return succ_.GetNoArena();
}
inline void Node::set_succ(const ::std::string& value) {
  
  succ_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chord.Node.succ)
}
#if LANG_CXX11
inline void Node::set_succ(::std::string&& value) {
  
  succ_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chord.Node.succ)
}
#endif
inline void Node::set_succ(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  succ_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chord.Node.succ)
}
inline void Node::set_succ(const char* value, size_t size) {
  
  succ_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chord.Node.succ)
}
inline ::std::string* Node::mutable_succ() {
  
  // @@protoc_insertion_point(field_mutable:chord.Node.succ)
  return succ_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_succ() {
  // @@protoc_insertion_point(field_release:chord.Node.succ)
  
  return succ_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_succ(::std::string* succ) {
  if (succ != nullptr) {
    
  } else {
    
  }
  succ_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), succ);
  // @@protoc_insertion_point(field_set_allocated:chord.Node.succ)
}

// string pred = 4;
inline void Node::clear_pred() {
  pred_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::pred() const {
  // @@protoc_insertion_point(field_get:chord.Node.pred)
  return pred_.GetNoArena();
}
inline void Node::set_pred(const ::std::string& value) {
  
  pred_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chord.Node.pred)
}
#if LANG_CXX11
inline void Node::set_pred(::std::string&& value) {
  
  pred_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chord.Node.pred)
}
#endif
inline void Node::set_pred(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  pred_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chord.Node.pred)
}
inline void Node::set_pred(const char* value, size_t size) {
  
  pred_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chord.Node.pred)
}
inline ::std::string* Node::mutable_pred() {
  
  // @@protoc_insertion_point(field_mutable:chord.Node.pred)
  return pred_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_pred() {
  // @@protoc_insertion_point(field_release:chord.Node.pred)
  
  return pred_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_pred(::std::string* pred) {
  if (pred != nullptr) {
    
  } else {
    
  }
  pred_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pred);
  // @@protoc_insertion_point(field_set_allocated:chord.Node.pred)
}

// .chord.FingerTable tbl = 5;
inline bool Node::has_tbl() const {
  return this != internal_default_instance() && tbl_ != nullptr;
}
inline void Node::clear_tbl() {
  if (GetArenaNoVirtual() == nullptr && tbl_ != nullptr) {
    delete tbl_;
  }
  tbl_ = nullptr;
}
inline const ::chord::FingerTable& Node::tbl() const {
  const ::chord::FingerTable* p = tbl_;
  // @@protoc_insertion_point(field_get:chord.Node.tbl)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::FingerTable*>(
      &::chord::_FingerTable_default_instance_);
}
inline ::chord::FingerTable* Node::release_tbl() {
  // @@protoc_insertion_point(field_release:chord.Node.tbl)
  
  ::chord::FingerTable* temp = tbl_;
  tbl_ = nullptr;
  return temp;
}
inline ::chord::FingerTable* Node::mutable_tbl() {
  
  if (tbl_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::FingerTable>(GetArenaNoVirtual());
    tbl_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.Node.tbl)
  return tbl_;
}
inline void Node::set_allocated_tbl(::chord::FingerTable* tbl) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tbl_;
  }
  if (tbl) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tbl = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, tbl, submessage_arena);
    }
    
  } else {
    
  }
  tbl_ = tbl;
  // @@protoc_insertion_point(field_set_allocated:chord.Node.tbl)
}

// -------------------------------------------------------------------

// FingerTable

// repeated .chord.Finger fingers = 1;
inline int FingerTable::fingers_size() const {
  return fingers_.size();
}
inline void FingerTable::clear_fingers() {
  fingers_.Clear();
}
inline ::chord::Finger* FingerTable::mutable_fingers(int index) {
  // @@protoc_insertion_point(field_mutable:chord.FingerTable.fingers)
  return fingers_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::chord::Finger >*
FingerTable::mutable_fingers() {
  // @@protoc_insertion_point(field_mutable_list:chord.FingerTable.fingers)
  return &fingers_;
}
inline const ::chord::Finger& FingerTable::fingers(int index) const {
  // @@protoc_insertion_point(field_get:chord.FingerTable.fingers)
  return fingers_.Get(index);
}
inline ::chord::Finger* FingerTable::add_fingers() {
  // @@protoc_insertion_point(field_add:chord.FingerTable.fingers)
  return fingers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::chord::Finger >&
FingerTable::fingers() const {
  // @@protoc_insertion_point(field_list:chord.FingerTable.fingers)
  return fingers_;
}

// -------------------------------------------------------------------

// Finger

// string addr = 1;
inline void Finger::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Finger::addr() const {
  // @@protoc_insertion_point(field_get:chord.Finger.addr)
  return addr_.GetNoArena();
}
inline void Finger::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chord.Finger.addr)
}
#if LANG_CXX11
inline void Finger::set_addr(::std::string&& value) {
  
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chord.Finger.addr)
}
#endif
inline void Finger::set_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chord.Finger.addr)
}
inline void Finger::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chord.Finger.addr)
}
inline ::std::string* Finger::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:chord.Finger.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Finger::release_addr() {
  // @@protoc_insertion_point(field_release:chord.Finger.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Finger::set_allocated_addr(::std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:chord.Finger.addr)
}

// uint32 idx = 2;
inline void Finger::clear_idx() {
  idx_ = 0u;
}
inline ::google::protobuf::uint32 Finger::idx() const {
  // @@protoc_insertion_point(field_get:chord.Finger.idx)
  return idx_;
}
inline void Finger::set_idx(::google::protobuf::uint32 value) {
  
  idx_ = value;
  // @@protoc_insertion_point(field_set:chord.Finger.idx)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chord

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_chord_2eproto
