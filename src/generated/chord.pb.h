// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: chord.proto

#ifndef PROTOBUF_INCLUDED_chord_2eproto
#define PROTOBUF_INCLUDED_chord_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_chord_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_chord_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[18]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_chord_2eproto();
namespace chord {
class ClosestPredFingerReq;
class ClosestPredFingerReqDefaultTypeInternal;
extern ClosestPredFingerReqDefaultTypeInternal _ClosestPredFingerReq_default_instance_;
class ClosestPredFingerResp;
class ClosestPredFingerRespDefaultTypeInternal;
extern ClosestPredFingerRespDefaultTypeInternal _ClosestPredFingerResp_default_instance_;
class FindPredReq;
class FindPredReqDefaultTypeInternal;
extern FindPredReqDefaultTypeInternal _FindPredReq_default_instance_;
class FindPredResp;
class FindPredRespDefaultTypeInternal;
extern FindPredRespDefaultTypeInternal _FindPredResp_default_instance_;
class FindSuccReq;
class FindSuccReqDefaultTypeInternal;
extern FindSuccReqDefaultTypeInternal _FindSuccReq_default_instance_;
class FindSuccResp;
class FindSuccRespDefaultTypeInternal;
extern FindSuccRespDefaultTypeInternal _FindSuccResp_default_instance_;
class FixFingersReq;
class FixFingersReqDefaultTypeInternal;
extern FixFingersReqDefaultTypeInternal _FixFingersReq_default_instance_;
class FixFingersResp;
class FixFingersRespDefaultTypeInternal;
extern FixFingersRespDefaultTypeInternal _FixFingersResp_default_instance_;
class GetInfoReq;
class GetInfoReqDefaultTypeInternal;
extern GetInfoReqDefaultTypeInternal _GetInfoReq_default_instance_;
class GetInfoResp;
class GetInfoRespDefaultTypeInternal;
extern GetInfoRespDefaultTypeInternal _GetInfoResp_default_instance_;
class JoinReq;
class JoinReqDefaultTypeInternal;
extern JoinReqDefaultTypeInternal _JoinReq_default_instance_;
class JoinResp;
class JoinRespDefaultTypeInternal;
extern JoinRespDefaultTypeInternal _JoinResp_default_instance_;
class Node;
class NodeDefaultTypeInternal;
extern NodeDefaultTypeInternal _Node_default_instance_;
class NodeInfo;
class NodeInfoDefaultTypeInternal;
extern NodeInfoDefaultTypeInternal _NodeInfo_default_instance_;
class NotifyReq;
class NotifyReqDefaultTypeInternal;
extern NotifyReqDefaultTypeInternal _NotifyReq_default_instance_;
class NotifyResp;
class NotifyRespDefaultTypeInternal;
extern NotifyRespDefaultTypeInternal _NotifyResp_default_instance_;
class StabilizeReq;
class StabilizeReqDefaultTypeInternal;
extern StabilizeReqDefaultTypeInternal _StabilizeReq_default_instance_;
class StabilizeResp;
class StabilizeRespDefaultTypeInternal;
extern StabilizeRespDefaultTypeInternal _StabilizeResp_default_instance_;
}  // namespace chord
namespace google {
namespace protobuf {
template<> ::chord::ClosestPredFingerReq* Arena::CreateMaybeMessage<::chord::ClosestPredFingerReq>(Arena*);
template<> ::chord::ClosestPredFingerResp* Arena::CreateMaybeMessage<::chord::ClosestPredFingerResp>(Arena*);
template<> ::chord::FindPredReq* Arena::CreateMaybeMessage<::chord::FindPredReq>(Arena*);
template<> ::chord::FindPredResp* Arena::CreateMaybeMessage<::chord::FindPredResp>(Arena*);
template<> ::chord::FindSuccReq* Arena::CreateMaybeMessage<::chord::FindSuccReq>(Arena*);
template<> ::chord::FindSuccResp* Arena::CreateMaybeMessage<::chord::FindSuccResp>(Arena*);
template<> ::chord::FixFingersReq* Arena::CreateMaybeMessage<::chord::FixFingersReq>(Arena*);
template<> ::chord::FixFingersResp* Arena::CreateMaybeMessage<::chord::FixFingersResp>(Arena*);
template<> ::chord::GetInfoReq* Arena::CreateMaybeMessage<::chord::GetInfoReq>(Arena*);
template<> ::chord::GetInfoResp* Arena::CreateMaybeMessage<::chord::GetInfoResp>(Arena*);
template<> ::chord::JoinReq* Arena::CreateMaybeMessage<::chord::JoinReq>(Arena*);
template<> ::chord::JoinResp* Arena::CreateMaybeMessage<::chord::JoinResp>(Arena*);
template<> ::chord::Node* Arena::CreateMaybeMessage<::chord::Node>(Arena*);
template<> ::chord::NodeInfo* Arena::CreateMaybeMessage<::chord::NodeInfo>(Arena*);
template<> ::chord::NotifyReq* Arena::CreateMaybeMessage<::chord::NotifyReq>(Arena*);
template<> ::chord::NotifyResp* Arena::CreateMaybeMessage<::chord::NotifyResp>(Arena*);
template<> ::chord::StabilizeReq* Arena::CreateMaybeMessage<::chord::StabilizeReq>(Arena*);
template<> ::chord::StabilizeResp* Arena::CreateMaybeMessage<::chord::StabilizeResp>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace chord {

// ===================================================================

class JoinReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.JoinReq) */ {
 public:
  JoinReq();
  virtual ~JoinReq();

  JoinReq(const JoinReq& from);

  inline JoinReq& operator=(const JoinReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinReq(JoinReq&& from) noexcept
    : JoinReq() {
    *this = ::std::move(from);
  }

  inline JoinReq& operator=(JoinReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const JoinReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinReq* internal_default_instance() {
    return reinterpret_cast<const JoinReq*>(
               &_JoinReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(JoinReq* other);
  friend void swap(JoinReq& a, JoinReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinReq* New() const final {
    return CreateMaybeMessage<JoinReq>(nullptr);
  }

  JoinReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JoinReq& from);
  void MergeFrom(const JoinReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node buddy = 1;
  bool has_buddy() const;
  void clear_buddy();
  static const int kBuddyFieldNumber = 1;
  const ::chord::Node& buddy() const;
  ::chord::Node* release_buddy();
  ::chord::Node* mutable_buddy();
  void set_allocated_buddy(::chord::Node* buddy);

  // @@protoc_insertion_point(class_scope:chord.JoinReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* buddy_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class JoinResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.JoinResp) */ {
 public:
  JoinResp();
  virtual ~JoinResp();

  JoinResp(const JoinResp& from);

  inline JoinResp& operator=(const JoinResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  JoinResp(JoinResp&& from) noexcept
    : JoinResp() {
    *this = ::std::move(from);
  }

  inline JoinResp& operator=(JoinResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const JoinResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const JoinResp* internal_default_instance() {
    return reinterpret_cast<const JoinResp*>(
               &_JoinResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(JoinResp* other);
  friend void swap(JoinResp& a, JoinResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline JoinResp* New() const final {
    return CreateMaybeMessage<JoinResp>(nullptr);
  }

  JoinResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<JoinResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const JoinResp& from);
  void MergeFrom(const JoinResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(JoinResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.JoinResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class GetInfoReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.GetInfoReq) */ {
 public:
  GetInfoReq();
  virtual ~GetInfoReq();

  GetInfoReq(const GetInfoReq& from);

  inline GetInfoReq& operator=(const GetInfoReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetInfoReq(GetInfoReq&& from) noexcept
    : GetInfoReq() {
    *this = ::std::move(from);
  }

  inline GetInfoReq& operator=(GetInfoReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetInfoReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInfoReq* internal_default_instance() {
    return reinterpret_cast<const GetInfoReq*>(
               &_GetInfoReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(GetInfoReq* other);
  friend void swap(GetInfoReq& a, GetInfoReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetInfoReq* New() const final {
    return CreateMaybeMessage<GetInfoReq>(nullptr);
  }

  GetInfoReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetInfoReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetInfoReq& from);
  void MergeFrom(const GetInfoReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.GetInfoReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class GetInfoResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.GetInfoResp) */ {
 public:
  GetInfoResp();
  virtual ~GetInfoResp();

  GetInfoResp(const GetInfoResp& from);

  inline GetInfoResp& operator=(const GetInfoResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GetInfoResp(GetInfoResp&& from) noexcept
    : GetInfoResp() {
    *this = ::std::move(from);
  }

  inline GetInfoResp& operator=(GetInfoResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GetInfoResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GetInfoResp* internal_default_instance() {
    return reinterpret_cast<const GetInfoResp*>(
               &_GetInfoResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(GetInfoResp* other);
  friend void swap(GetInfoResp& a, GetInfoResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GetInfoResp* New() const final {
    return CreateMaybeMessage<GetInfoResp>(nullptr);
  }

  GetInfoResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GetInfoResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GetInfoResp& from);
  void MergeFrom(const GetInfoResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetInfoResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.NodeInfo info = 1;
  bool has_info() const;
  void clear_info();
  static const int kInfoFieldNumber = 1;
  const ::chord::NodeInfo& info() const;
  ::chord::NodeInfo* release_info();
  ::chord::NodeInfo* mutable_info();
  void set_allocated_info(::chord::NodeInfo* info);

  // @@protoc_insertion_point(class_scope:chord.GetInfoResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::NodeInfo* info_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FindSuccReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FindSuccReq) */ {
 public:
  FindSuccReq();
  virtual ~FindSuccReq();

  FindSuccReq(const FindSuccReq& from);

  inline FindSuccReq& operator=(const FindSuccReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindSuccReq(FindSuccReq&& from) noexcept
    : FindSuccReq() {
    *this = ::std::move(from);
  }

  inline FindSuccReq& operator=(FindSuccReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FindSuccReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindSuccReq* internal_default_instance() {
    return reinterpret_cast<const FindSuccReq*>(
               &_FindSuccReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(FindSuccReq* other);
  friend void swap(FindSuccReq& a, FindSuccReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindSuccReq* New() const final {
    return CreateMaybeMessage<FindSuccReq>(nullptr);
  }

  FindSuccReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindSuccReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindSuccReq& from);
  void MergeFrom(const FindSuccReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindSuccReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint32 key() const;
  void set_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chord.FindSuccReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FindSuccResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FindSuccResp) */ {
 public:
  FindSuccResp();
  virtual ~FindSuccResp();

  FindSuccResp(const FindSuccResp& from);

  inline FindSuccResp& operator=(const FindSuccResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindSuccResp(FindSuccResp&& from) noexcept
    : FindSuccResp() {
    *this = ::std::move(from);
  }

  inline FindSuccResp& operator=(FindSuccResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FindSuccResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindSuccResp* internal_default_instance() {
    return reinterpret_cast<const FindSuccResp*>(
               &_FindSuccResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(FindSuccResp* other);
  friend void swap(FindSuccResp& a, FindSuccResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindSuccResp* New() const final {
    return CreateMaybeMessage<FindSuccResp>(nullptr);
  }

  FindSuccResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindSuccResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindSuccResp& from);
  void MergeFrom(const FindSuccResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindSuccResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node succ = 1;
  bool has_succ() const;
  void clear_succ();
  static const int kSuccFieldNumber = 1;
  const ::chord::Node& succ() const;
  ::chord::Node* release_succ();
  ::chord::Node* mutable_succ();
  void set_allocated_succ(::chord::Node* succ);

  // @@protoc_insertion_point(class_scope:chord.FindSuccResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* succ_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FindPredReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FindPredReq) */ {
 public:
  FindPredReq();
  virtual ~FindPredReq();

  FindPredReq(const FindPredReq& from);

  inline FindPredReq& operator=(const FindPredReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindPredReq(FindPredReq&& from) noexcept
    : FindPredReq() {
    *this = ::std::move(from);
  }

  inline FindPredReq& operator=(FindPredReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FindPredReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindPredReq* internal_default_instance() {
    return reinterpret_cast<const FindPredReq*>(
               &_FindPredReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(FindPredReq* other);
  friend void swap(FindPredReq& a, FindPredReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindPredReq* New() const final {
    return CreateMaybeMessage<FindPredReq>(nullptr);
  }

  FindPredReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindPredReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindPredReq& from);
  void MergeFrom(const FindPredReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindPredReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint32 key() const;
  void set_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chord.FindPredReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FindPredResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FindPredResp) */ {
 public:
  FindPredResp();
  virtual ~FindPredResp();

  FindPredResp(const FindPredResp& from);

  inline FindPredResp& operator=(const FindPredResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FindPredResp(FindPredResp&& from) noexcept
    : FindPredResp() {
    *this = ::std::move(from);
  }

  inline FindPredResp& operator=(FindPredResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FindPredResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FindPredResp* internal_default_instance() {
    return reinterpret_cast<const FindPredResp*>(
               &_FindPredResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(FindPredResp* other);
  friend void swap(FindPredResp& a, FindPredResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FindPredResp* New() const final {
    return CreateMaybeMessage<FindPredResp>(nullptr);
  }

  FindPredResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FindPredResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FindPredResp& from);
  void MergeFrom(const FindPredResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FindPredResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node pred = 1;
  bool has_pred() const;
  void clear_pred();
  static const int kPredFieldNumber = 1;
  const ::chord::Node& pred() const;
  ::chord::Node* release_pred();
  ::chord::Node* mutable_pred();
  void set_allocated_pred(::chord::Node* pred);

  // @@protoc_insertion_point(class_scope:chord.FindPredResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* pred_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class ClosestPredFingerReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.ClosestPredFingerReq) */ {
 public:
  ClosestPredFingerReq();
  virtual ~ClosestPredFingerReq();

  ClosestPredFingerReq(const ClosestPredFingerReq& from);

  inline ClosestPredFingerReq& operator=(const ClosestPredFingerReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClosestPredFingerReq(ClosestPredFingerReq&& from) noexcept
    : ClosestPredFingerReq() {
    *this = ::std::move(from);
  }

  inline ClosestPredFingerReq& operator=(ClosestPredFingerReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ClosestPredFingerReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClosestPredFingerReq* internal_default_instance() {
    return reinterpret_cast<const ClosestPredFingerReq*>(
               &_ClosestPredFingerReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(ClosestPredFingerReq* other);
  friend void swap(ClosestPredFingerReq& a, ClosestPredFingerReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClosestPredFingerReq* New() const final {
    return CreateMaybeMessage<ClosestPredFingerReq>(nullptr);
  }

  ClosestPredFingerReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClosestPredFingerReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClosestPredFingerReq& from);
  void MergeFrom(const ClosestPredFingerReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClosestPredFingerReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint32 key = 1;
  void clear_key();
  static const int kKeyFieldNumber = 1;
  ::google::protobuf::uint32 key() const;
  void set_key(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chord.ClosestPredFingerReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 key_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class ClosestPredFingerResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.ClosestPredFingerResp) */ {
 public:
  ClosestPredFingerResp();
  virtual ~ClosestPredFingerResp();

  ClosestPredFingerResp(const ClosestPredFingerResp& from);

  inline ClosestPredFingerResp& operator=(const ClosestPredFingerResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ClosestPredFingerResp(ClosestPredFingerResp&& from) noexcept
    : ClosestPredFingerResp() {
    *this = ::std::move(from);
  }

  inline ClosestPredFingerResp& operator=(ClosestPredFingerResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ClosestPredFingerResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ClosestPredFingerResp* internal_default_instance() {
    return reinterpret_cast<const ClosestPredFingerResp*>(
               &_ClosestPredFingerResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(ClosestPredFingerResp* other);
  friend void swap(ClosestPredFingerResp& a, ClosestPredFingerResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ClosestPredFingerResp* New() const final {
    return CreateMaybeMessage<ClosestPredFingerResp>(nullptr);
  }

  ClosestPredFingerResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ClosestPredFingerResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ClosestPredFingerResp& from);
  void MergeFrom(const ClosestPredFingerResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ClosestPredFingerResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node pred_finger = 1;
  bool has_pred_finger() const;
  void clear_pred_finger();
  static const int kPredFingerFieldNumber = 1;
  const ::chord::Node& pred_finger() const;
  ::chord::Node* release_pred_finger();
  ::chord::Node* mutable_pred_finger();
  void set_allocated_pred_finger(::chord::Node* pred_finger);

  // @@protoc_insertion_point(class_scope:chord.ClosestPredFingerResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* pred_finger_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class StabilizeReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.StabilizeReq) */ {
 public:
  StabilizeReq();
  virtual ~StabilizeReq();

  StabilizeReq(const StabilizeReq& from);

  inline StabilizeReq& operator=(const StabilizeReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StabilizeReq(StabilizeReq&& from) noexcept
    : StabilizeReq() {
    *this = ::std::move(from);
  }

  inline StabilizeReq& operator=(StabilizeReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StabilizeReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StabilizeReq* internal_default_instance() {
    return reinterpret_cast<const StabilizeReq*>(
               &_StabilizeReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(StabilizeReq* other);
  friend void swap(StabilizeReq& a, StabilizeReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StabilizeReq* New() const final {
    return CreateMaybeMessage<StabilizeReq>(nullptr);
  }

  StabilizeReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StabilizeReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StabilizeReq& from);
  void MergeFrom(const StabilizeReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StabilizeReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.StabilizeReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class StabilizeResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.StabilizeResp) */ {
 public:
  StabilizeResp();
  virtual ~StabilizeResp();

  StabilizeResp(const StabilizeResp& from);

  inline StabilizeResp& operator=(const StabilizeResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StabilizeResp(StabilizeResp&& from) noexcept
    : StabilizeResp() {
    *this = ::std::move(from);
  }

  inline StabilizeResp& operator=(StabilizeResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StabilizeResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StabilizeResp* internal_default_instance() {
    return reinterpret_cast<const StabilizeResp*>(
               &_StabilizeResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(StabilizeResp* other);
  friend void swap(StabilizeResp& a, StabilizeResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StabilizeResp* New() const final {
    return CreateMaybeMessage<StabilizeResp>(nullptr);
  }

  StabilizeResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StabilizeResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StabilizeResp& from);
  void MergeFrom(const StabilizeResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StabilizeResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.StabilizeResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class NotifyReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.NotifyReq) */ {
 public:
  NotifyReq();
  virtual ~NotifyReq();

  NotifyReq(const NotifyReq& from);

  inline NotifyReq& operator=(const NotifyReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotifyReq(NotifyReq&& from) noexcept
    : NotifyReq() {
    *this = ::std::move(from);
  }

  inline NotifyReq& operator=(NotifyReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NotifyReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotifyReq* internal_default_instance() {
    return reinterpret_cast<const NotifyReq*>(
               &_NotifyReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(NotifyReq* other);
  friend void swap(NotifyReq& a, NotifyReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotifyReq* New() const final {
    return CreateMaybeMessage<NotifyReq>(nullptr);
  }

  NotifyReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NotifyReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NotifyReq& from);
  void MergeFrom(const NotifyReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node potential_pred = 1;
  bool has_potential_pred() const;
  void clear_potential_pred();
  static const int kPotentialPredFieldNumber = 1;
  const ::chord::Node& potential_pred() const;
  ::chord::Node* release_potential_pred();
  ::chord::Node* mutable_potential_pred();
  void set_allocated_potential_pred(::chord::Node* potential_pred);

  // @@protoc_insertion_point(class_scope:chord.NotifyReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* potential_pred_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class NotifyResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.NotifyResp) */ {
 public:
  NotifyResp();
  virtual ~NotifyResp();

  NotifyResp(const NotifyResp& from);

  inline NotifyResp& operator=(const NotifyResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NotifyResp(NotifyResp&& from) noexcept
    : NotifyResp() {
    *this = ::std::move(from);
  }

  inline NotifyResp& operator=(NotifyResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NotifyResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NotifyResp* internal_default_instance() {
    return reinterpret_cast<const NotifyResp*>(
               &_NotifyResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(NotifyResp* other);
  friend void swap(NotifyResp& a, NotifyResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NotifyResp* New() const final {
    return CreateMaybeMessage<NotifyResp>(nullptr);
  }

  NotifyResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NotifyResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NotifyResp& from);
  void MergeFrom(const NotifyResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NotifyResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.NotifyResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FixFingersReq final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FixFingersReq) */ {
 public:
  FixFingersReq();
  virtual ~FixFingersReq();

  FixFingersReq(const FixFingersReq& from);

  inline FixFingersReq& operator=(const FixFingersReq& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixFingersReq(FixFingersReq&& from) noexcept
    : FixFingersReq() {
    *this = ::std::move(from);
  }

  inline FixFingersReq& operator=(FixFingersReq&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FixFingersReq& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixFingersReq* internal_default_instance() {
    return reinterpret_cast<const FixFingersReq*>(
               &_FixFingersReq_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(FixFingersReq* other);
  friend void swap(FixFingersReq& a, FixFingersReq& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixFingersReq* New() const final {
    return CreateMaybeMessage<FixFingersReq>(nullptr);
  }

  FixFingersReq* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FixFingersReq>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FixFingersReq& from);
  void MergeFrom(const FixFingersReq& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixFingersReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.FixFingersReq)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class FixFingersResp final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.FixFingersResp) */ {
 public:
  FixFingersResp();
  virtual ~FixFingersResp();

  FixFingersResp(const FixFingersResp& from);

  inline FixFingersResp& operator=(const FixFingersResp& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FixFingersResp(FixFingersResp&& from) noexcept
    : FixFingersResp() {
    *this = ::std::move(from);
  }

  inline FixFingersResp& operator=(FixFingersResp&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FixFingersResp& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FixFingersResp* internal_default_instance() {
    return reinterpret_cast<const FixFingersResp*>(
               &_FixFingersResp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(FixFingersResp* other);
  friend void swap(FixFingersResp& a, FixFingersResp& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FixFingersResp* New() const final {
    return CreateMaybeMessage<FixFingersResp>(nullptr);
  }

  FixFingersResp* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FixFingersResp>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FixFingersResp& from);
  void MergeFrom(const FixFingersResp& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FixFingersResp* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:chord.FixFingersResp)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class Node final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.Node) */ {
 public:
  Node();
  virtual ~Node();

  Node(const Node& from);

  inline Node& operator=(const Node& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Node(Node&& from) noexcept
    : Node() {
    *this = ::std::move(from);
  }

  inline Node& operator=(Node&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Node& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Node* internal_default_instance() {
    return reinterpret_cast<const Node*>(
               &_Node_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(Node* other);
  friend void swap(Node& a, Node& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Node* New() const final {
    return CreateMaybeMessage<Node>(nullptr);
  }

  Node* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Node>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Node& from);
  void MergeFrom(const Node& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Node* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string addr = 1;
  void clear_addr();
  static const int kAddrFieldNumber = 1;
  const ::std::string& addr() const;
  void set_addr(const ::std::string& value);
  #if LANG_CXX11
  void set_addr(::std::string&& value);
  #endif
  void set_addr(const char* value);
  void set_addr(const char* value, size_t size);
  ::std::string* mutable_addr();
  ::std::string* release_addr();
  void set_allocated_addr(::std::string* addr);

  // uint32 id = 2;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::uint32 id() const;
  void set_id(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:chord.Node)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr addr_;
  ::google::protobuf::uint32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// -------------------------------------------------------------------

class NodeInfo final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:chord.NodeInfo) */ {
 public:
  NodeInfo();
  virtual ~NodeInfo();

  NodeInfo(const NodeInfo& from);

  inline NodeInfo& operator=(const NodeInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NodeInfo(NodeInfo&& from) noexcept
    : NodeInfo() {
    *this = ::std::move(from);
  }

  inline NodeInfo& operator=(NodeInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NodeInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NodeInfo* internal_default_instance() {
    return reinterpret_cast<const NodeInfo*>(
               &_NodeInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(NodeInfo* other);
  friend void swap(NodeInfo& a, NodeInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NodeInfo* New() const final {
    return CreateMaybeMessage<NodeInfo>(nullptr);
  }

  NodeInfo* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NodeInfo>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NodeInfo& from);
  void MergeFrom(const NodeInfo& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NodeInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .chord.Node self = 1;
  bool has_self() const;
  void clear_self();
  static const int kSelfFieldNumber = 1;
  const ::chord::Node& self() const;
  ::chord::Node* release_self();
  ::chord::Node* mutable_self();
  void set_allocated_self(::chord::Node* self);

  // .chord.Node succ = 2;
  bool has_succ() const;
  void clear_succ();
  static const int kSuccFieldNumber = 2;
  const ::chord::Node& succ() const;
  ::chord::Node* release_succ();
  ::chord::Node* mutable_succ();
  void set_allocated_succ(::chord::Node* succ);

  // .chord.Node pred = 3;
  bool has_pred() const;
  void clear_pred();
  static const int kPredFieldNumber = 3;
  const ::chord::Node& pred() const;
  ::chord::Node* release_pred();
  ::chord::Node* mutable_pred();
  void set_allocated_pred(::chord::Node* pred);

  // @@protoc_insertion_point(class_scope:chord.NodeInfo)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::chord::Node* self_;
  ::chord::Node* succ_;
  ::chord::Node* pred_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_chord_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// JoinReq

// .chord.Node buddy = 1;
inline bool JoinReq::has_buddy() const {
  return this != internal_default_instance() && buddy_ != nullptr;
}
inline void JoinReq::clear_buddy() {
  if (GetArenaNoVirtual() == nullptr && buddy_ != nullptr) {
    delete buddy_;
  }
  buddy_ = nullptr;
}
inline const ::chord::Node& JoinReq::buddy() const {
  const ::chord::Node* p = buddy_;
  // @@protoc_insertion_point(field_get:chord.JoinReq.buddy)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* JoinReq::release_buddy() {
  // @@protoc_insertion_point(field_release:chord.JoinReq.buddy)
  
  ::chord::Node* temp = buddy_;
  buddy_ = nullptr;
  return temp;
}
inline ::chord::Node* JoinReq::mutable_buddy() {
  
  if (buddy_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    buddy_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.JoinReq.buddy)
  return buddy_;
}
inline void JoinReq::set_allocated_buddy(::chord::Node* buddy) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete buddy_;
  }
  if (buddy) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buddy = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, buddy, submessage_arena);
    }
    
  } else {
    
  }
  buddy_ = buddy;
  // @@protoc_insertion_point(field_set_allocated:chord.JoinReq.buddy)
}

// -------------------------------------------------------------------

// JoinResp

// -------------------------------------------------------------------

// GetInfoReq

// -------------------------------------------------------------------

// GetInfoResp

// .chord.NodeInfo info = 1;
inline bool GetInfoResp::has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline void GetInfoResp::clear_info() {
  if (GetArenaNoVirtual() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::chord::NodeInfo& GetInfoResp::info() const {
  const ::chord::NodeInfo* p = info_;
  // @@protoc_insertion_point(field_get:chord.GetInfoResp.info)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::NodeInfo*>(
      &::chord::_NodeInfo_default_instance_);
}
inline ::chord::NodeInfo* GetInfoResp::release_info() {
  // @@protoc_insertion_point(field_release:chord.GetInfoResp.info)
  
  ::chord::NodeInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::chord::NodeInfo* GetInfoResp::mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::NodeInfo>(GetArenaNoVirtual());
    info_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.GetInfoResp.info)
  return info_;
}
inline void GetInfoResp::set_allocated_info(::chord::NodeInfo* info) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      info = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:chord.GetInfoResp.info)
}

// -------------------------------------------------------------------

// FindSuccReq

// uint32 key = 1;
inline void FindSuccReq::clear_key() {
  key_ = 0u;
}
inline ::google::protobuf::uint32 FindSuccReq::key() const {
  // @@protoc_insertion_point(field_get:chord.FindSuccReq.key)
  return key_;
}
inline void FindSuccReq::set_key(::google::protobuf::uint32 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:chord.FindSuccReq.key)
}

// -------------------------------------------------------------------

// FindSuccResp

// .chord.Node succ = 1;
inline bool FindSuccResp::has_succ() const {
  return this != internal_default_instance() && succ_ != nullptr;
}
inline void FindSuccResp::clear_succ() {
  if (GetArenaNoVirtual() == nullptr && succ_ != nullptr) {
    delete succ_;
  }
  succ_ = nullptr;
}
inline const ::chord::Node& FindSuccResp::succ() const {
  const ::chord::Node* p = succ_;
  // @@protoc_insertion_point(field_get:chord.FindSuccResp.succ)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* FindSuccResp::release_succ() {
  // @@protoc_insertion_point(field_release:chord.FindSuccResp.succ)
  
  ::chord::Node* temp = succ_;
  succ_ = nullptr;
  return temp;
}
inline ::chord::Node* FindSuccResp::mutable_succ() {
  
  if (succ_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    succ_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.FindSuccResp.succ)
  return succ_;
}
inline void FindSuccResp::set_allocated_succ(::chord::Node* succ) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete succ_;
  }
  if (succ) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      succ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, succ, submessage_arena);
    }
    
  } else {
    
  }
  succ_ = succ;
  // @@protoc_insertion_point(field_set_allocated:chord.FindSuccResp.succ)
}

// -------------------------------------------------------------------

// FindPredReq

// uint32 key = 1;
inline void FindPredReq::clear_key() {
  key_ = 0u;
}
inline ::google::protobuf::uint32 FindPredReq::key() const {
  // @@protoc_insertion_point(field_get:chord.FindPredReq.key)
  return key_;
}
inline void FindPredReq::set_key(::google::protobuf::uint32 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:chord.FindPredReq.key)
}

// -------------------------------------------------------------------

// FindPredResp

// .chord.Node pred = 1;
inline bool FindPredResp::has_pred() const {
  return this != internal_default_instance() && pred_ != nullptr;
}
inline void FindPredResp::clear_pred() {
  if (GetArenaNoVirtual() == nullptr && pred_ != nullptr) {
    delete pred_;
  }
  pred_ = nullptr;
}
inline const ::chord::Node& FindPredResp::pred() const {
  const ::chord::Node* p = pred_;
  // @@protoc_insertion_point(field_get:chord.FindPredResp.pred)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* FindPredResp::release_pred() {
  // @@protoc_insertion_point(field_release:chord.FindPredResp.pred)
  
  ::chord::Node* temp = pred_;
  pred_ = nullptr;
  return temp;
}
inline ::chord::Node* FindPredResp::mutable_pred() {
  
  if (pred_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    pred_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.FindPredResp.pred)
  return pred_;
}
inline void FindPredResp::set_allocated_pred(::chord::Node* pred) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pred_;
  }
  if (pred) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pred = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pred, submessage_arena);
    }
    
  } else {
    
  }
  pred_ = pred;
  // @@protoc_insertion_point(field_set_allocated:chord.FindPredResp.pred)
}

// -------------------------------------------------------------------

// ClosestPredFingerReq

// uint32 key = 1;
inline void ClosestPredFingerReq::clear_key() {
  key_ = 0u;
}
inline ::google::protobuf::uint32 ClosestPredFingerReq::key() const {
  // @@protoc_insertion_point(field_get:chord.ClosestPredFingerReq.key)
  return key_;
}
inline void ClosestPredFingerReq::set_key(::google::protobuf::uint32 value) {
  
  key_ = value;
  // @@protoc_insertion_point(field_set:chord.ClosestPredFingerReq.key)
}

// -------------------------------------------------------------------

// ClosestPredFingerResp

// .chord.Node pred_finger = 1;
inline bool ClosestPredFingerResp::has_pred_finger() const {
  return this != internal_default_instance() && pred_finger_ != nullptr;
}
inline void ClosestPredFingerResp::clear_pred_finger() {
  if (GetArenaNoVirtual() == nullptr && pred_finger_ != nullptr) {
    delete pred_finger_;
  }
  pred_finger_ = nullptr;
}
inline const ::chord::Node& ClosestPredFingerResp::pred_finger() const {
  const ::chord::Node* p = pred_finger_;
  // @@protoc_insertion_point(field_get:chord.ClosestPredFingerResp.pred_finger)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* ClosestPredFingerResp::release_pred_finger() {
  // @@protoc_insertion_point(field_release:chord.ClosestPredFingerResp.pred_finger)
  
  ::chord::Node* temp = pred_finger_;
  pred_finger_ = nullptr;
  return temp;
}
inline ::chord::Node* ClosestPredFingerResp::mutable_pred_finger() {
  
  if (pred_finger_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    pred_finger_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.ClosestPredFingerResp.pred_finger)
  return pred_finger_;
}
inline void ClosestPredFingerResp::set_allocated_pred_finger(::chord::Node* pred_finger) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pred_finger_;
  }
  if (pred_finger) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pred_finger = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pred_finger, submessage_arena);
    }
    
  } else {
    
  }
  pred_finger_ = pred_finger;
  // @@protoc_insertion_point(field_set_allocated:chord.ClosestPredFingerResp.pred_finger)
}

// -------------------------------------------------------------------

// StabilizeReq

// -------------------------------------------------------------------

// StabilizeResp

// -------------------------------------------------------------------

// NotifyReq

// .chord.Node potential_pred = 1;
inline bool NotifyReq::has_potential_pred() const {
  return this != internal_default_instance() && potential_pred_ != nullptr;
}
inline void NotifyReq::clear_potential_pred() {
  if (GetArenaNoVirtual() == nullptr && potential_pred_ != nullptr) {
    delete potential_pred_;
  }
  potential_pred_ = nullptr;
}
inline const ::chord::Node& NotifyReq::potential_pred() const {
  const ::chord::Node* p = potential_pred_;
  // @@protoc_insertion_point(field_get:chord.NotifyReq.potential_pred)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* NotifyReq::release_potential_pred() {
  // @@protoc_insertion_point(field_release:chord.NotifyReq.potential_pred)
  
  ::chord::Node* temp = potential_pred_;
  potential_pred_ = nullptr;
  return temp;
}
inline ::chord::Node* NotifyReq::mutable_potential_pred() {
  
  if (potential_pred_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    potential_pred_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.NotifyReq.potential_pred)
  return potential_pred_;
}
inline void NotifyReq::set_allocated_potential_pred(::chord::Node* potential_pred) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete potential_pred_;
  }
  if (potential_pred) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      potential_pred = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, potential_pred, submessage_arena);
    }
    
  } else {
    
  }
  potential_pred_ = potential_pred;
  // @@protoc_insertion_point(field_set_allocated:chord.NotifyReq.potential_pred)
}

// -------------------------------------------------------------------

// NotifyResp

// -------------------------------------------------------------------

// FixFingersReq

// -------------------------------------------------------------------

// FixFingersResp

// -------------------------------------------------------------------

// Node

// string addr = 1;
inline void Node::clear_addr() {
  addr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Node::addr() const {
  // @@protoc_insertion_point(field_get:chord.Node.addr)
  return addr_.GetNoArena();
}
inline void Node::set_addr(const ::std::string& value) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:chord.Node.addr)
}
#if LANG_CXX11
inline void Node::set_addr(::std::string&& value) {
  
  addr_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:chord.Node.addr)
}
#endif
inline void Node::set_addr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:chord.Node.addr)
}
inline void Node::set_addr(const char* value, size_t size) {
  
  addr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:chord.Node.addr)
}
inline ::std::string* Node::mutable_addr() {
  
  // @@protoc_insertion_point(field_mutable:chord.Node.addr)
  return addr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Node::release_addr() {
  // @@protoc_insertion_point(field_release:chord.Node.addr)
  
  return addr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Node::set_allocated_addr(::std::string* addr) {
  if (addr != nullptr) {
    
  } else {
    
  }
  addr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), addr);
  // @@protoc_insertion_point(field_set_allocated:chord.Node.addr)
}

// uint32 id = 2;
inline void Node::clear_id() {
  id_ = 0u;
}
inline ::google::protobuf::uint32 Node::id() const {
  // @@protoc_insertion_point(field_get:chord.Node.id)
  return id_;
}
inline void Node::set_id(::google::protobuf::uint32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:chord.Node.id)
}

// -------------------------------------------------------------------

// NodeInfo

// .chord.Node self = 1;
inline bool NodeInfo::has_self() const {
  return this != internal_default_instance() && self_ != nullptr;
}
inline void NodeInfo::clear_self() {
  if (GetArenaNoVirtual() == nullptr && self_ != nullptr) {
    delete self_;
  }
  self_ = nullptr;
}
inline const ::chord::Node& NodeInfo::self() const {
  const ::chord::Node* p = self_;
  // @@protoc_insertion_point(field_get:chord.NodeInfo.self)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* NodeInfo::release_self() {
  // @@protoc_insertion_point(field_release:chord.NodeInfo.self)
  
  ::chord::Node* temp = self_;
  self_ = nullptr;
  return temp;
}
inline ::chord::Node* NodeInfo::mutable_self() {
  
  if (self_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    self_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.NodeInfo.self)
  return self_;
}
inline void NodeInfo::set_allocated_self(::chord::Node* self) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete self_;
  }
  if (self) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      self = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, self, submessage_arena);
    }
    
  } else {
    
  }
  self_ = self;
  // @@protoc_insertion_point(field_set_allocated:chord.NodeInfo.self)
}

// .chord.Node succ = 2;
inline bool NodeInfo::has_succ() const {
  return this != internal_default_instance() && succ_ != nullptr;
}
inline void NodeInfo::clear_succ() {
  if (GetArenaNoVirtual() == nullptr && succ_ != nullptr) {
    delete succ_;
  }
  succ_ = nullptr;
}
inline const ::chord::Node& NodeInfo::succ() const {
  const ::chord::Node* p = succ_;
  // @@protoc_insertion_point(field_get:chord.NodeInfo.succ)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* NodeInfo::release_succ() {
  // @@protoc_insertion_point(field_release:chord.NodeInfo.succ)
  
  ::chord::Node* temp = succ_;
  succ_ = nullptr;
  return temp;
}
inline ::chord::Node* NodeInfo::mutable_succ() {
  
  if (succ_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    succ_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.NodeInfo.succ)
  return succ_;
}
inline void NodeInfo::set_allocated_succ(::chord::Node* succ) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete succ_;
  }
  if (succ) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      succ = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, succ, submessage_arena);
    }
    
  } else {
    
  }
  succ_ = succ;
  // @@protoc_insertion_point(field_set_allocated:chord.NodeInfo.succ)
}

// .chord.Node pred = 3;
inline bool NodeInfo::has_pred() const {
  return this != internal_default_instance() && pred_ != nullptr;
}
inline void NodeInfo::clear_pred() {
  if (GetArenaNoVirtual() == nullptr && pred_ != nullptr) {
    delete pred_;
  }
  pred_ = nullptr;
}
inline const ::chord::Node& NodeInfo::pred() const {
  const ::chord::Node* p = pred_;
  // @@protoc_insertion_point(field_get:chord.NodeInfo.pred)
  return p != nullptr ? *p : *reinterpret_cast<const ::chord::Node*>(
      &::chord::_Node_default_instance_);
}
inline ::chord::Node* NodeInfo::release_pred() {
  // @@protoc_insertion_point(field_release:chord.NodeInfo.pred)
  
  ::chord::Node* temp = pred_;
  pred_ = nullptr;
  return temp;
}
inline ::chord::Node* NodeInfo::mutable_pred() {
  
  if (pred_ == nullptr) {
    auto* p = CreateMaybeMessage<::chord::Node>(GetArenaNoVirtual());
    pred_ = p;
  }
  // @@protoc_insertion_point(field_mutable:chord.NodeInfo.pred)
  return pred_;
}
inline void NodeInfo::set_allocated_pred(::chord::Node* pred) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete pred_;
  }
  if (pred) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pred = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, pred, submessage_arena);
    }
    
  } else {
    
  }
  pred_ = pred;
  // @@protoc_insertion_point(field_set_allocated:chord.NodeInfo.pred)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace chord

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_chord_2eproto
